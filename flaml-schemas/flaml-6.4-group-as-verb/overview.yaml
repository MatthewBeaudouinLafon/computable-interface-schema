# This version aims to harmonize covers, groups and containers, basically combining them as groups.
# It also introduces 'derived groups' as the way to avoid repeating yourself. The group then indexes into each use.
# 6.4.1: Add the <> icon for instance attributes to disambiguate with creating attribute objects.
#        eg. my-object:                           # object
#              group foreach:                     # relation
#               - (gui) my-view:                  # instance
#                   /marks <>: /my-object-attribute  # instance mapping: instance attribute

# any-expression: object-expression | struct-expression | view-expression | action-expression

# Object expressions
- obj-name: # PARSE: ID=obj-name
    mapto: object-expression # PARSE: SRC:ID=obj-name REL:mapto TRG:ID=object-expression
    ->: object-expression

    subset: object-expression # PARSE: SRC:ID=obj-name REL:subset TRG:ID=object-expression
    .: object-expression

    # Groups are both objects and structures (eg. in views)
    # Simple groups "carve up "
    # PARSE: SRC:ID=obj-name REL:group TRG:ID=object-expre
    groups: object-expression # affected objects

    # Subgroups
    # List all of the subsets of the affected content
    # PARSE: SRC:ID=subset-expression REL:subset TRG:ID=object-name
    subgroups: subset-expression # subset of the affected objects

- def (derivable-group):
    # PARSE: ID=argument-name
    arguments: any-expression # arguments are prefixed with $.

    # foreach groups "build up"
    groups foreach: # TODO: better keyword? Is it even needed, or could it just be groups?
      # PARSE: SRC:ID=instance-name REL:group-foreach TRG:ID=expression
      - any-expression # this will be for each item.

# Concise object expressions. These "compile down" to a subset.
# Order of operation: / . -> # TODO: need to verify this against tests
- obj-name.subset # PARSE: SRC=obj-name REL:subset TRG:ID=obj-name.subset
- obj-name->target-obj # PARSE: SRC=obj-name REL:mapto TRG:ID=target-obj

# Alias nodes to equate them
- object-name =: other-name # PARSE: SRC=obj-name REL:alias TRG:ID=othername

# Combining objects with and makes them a series of subsets.
# PARSE `and` syntax: SRC:ID=object-expression REL:subset REL:ID=object-expression and object-expression and ...
- object-name =: object-expression and object-expression and object-expression

# Instantiating derivable groups.
# PARSE: ID=my-instance, type=derived-group
- (my-derived-group) my-instance:
    # PARSE: SRC=my-instance/myargument REL:alias TRG:ID=obj-expression
    /my-argument =: any-expression # fill in the placeholder ie. an alias

    # PARSE: SRC=any-expression REL:alias TRG:ID=my-instance/myattribute
    /my-attribute: any-expression # expression->attribute

# Structures. They are also groups, potentially with placeholders
# PARSE: ID=my-struct, type=structure
- (structure) my-struct:
    # PARSE: SRC:ID=my-struct REL:affects TRG:ID=object-expression
    affects: object-expression

    # PARSE: SRC:ID=my-struct REL:covers TRG:ID=object-expression
    covers: name-expression # These are groups of the affected objects

    # PARSE: SRC=my-instance/myargument REL:alias TRG:ID=obj-expression
    /argument =: any-expression

# Views. They are also groups, with placeholders for marks and encodings
- (view-type) my-view:
    /marks.mark-type: object-expression
    /encoding.encoding-type: structure-expression
# TODO: actions

- notes:
    - when I do a `group foreach`, how do I talk about just the items in the group? Using /thing works, but it's not quite right when you have already defined the thing
    - (from data-navigator) could have a "derives-from" field for structures, seems important.
    - (from olli) could use `$self` in `group forall`
---
items =: files and folders
type:
  groups: items
  subgroups: files, folders

(gui) cool-view:
  /marks: items
  /encoding.cluster: type
